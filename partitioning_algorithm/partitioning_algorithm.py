
import copy

class partitioning:
    def __init__(self, subregion:list, part_number:int, index:int, dim:int, serial: int  ):
        '''
       Partitioning Algorithm
       Parameters:
    #         subregion: region need to be partitioned
    #         part_number (int): how many subregions that needed to be generated by the algorithm
    #         index (int): indicate the demision needed to be partitioned
    #         dim(int): dimension
    #         serial (int): the serial number of the subregion that needed to be partitioned

    #     Returns:
    #         part_sub (dist): subregions with new serial numbers
        '''
        self.subregion = subregion ##subregions that needed to be partitioned
        self.part_number = part_number
        self.index = index
        self.dim = dim
        self.serial = serial
       

    def __condition__(self):
        assert self.subregion[0].ndim == self.dim
        assert self.subregion[1].ndim == self.dim

    def partitioning_algorithm(self):
        
        self.__condition__
        part_sub = {}
        sl_coordinate_upper = self.subregion[self.index][1]
        sl_coordinate_lower = self.subregion[self.index][0]
        for j in range(self.part_number): 
            l_coordinate_lower = float((sl_coordinate_upper - sl_coordinate_lower[self.index]))* j / self.part_number+ \
                                                    sl_coordinate_lower
            l_coordinate_upper = float((sl_coordinate_upper- sl_coordinate_lower) * (j + 1)) / \
                                                    self.part_number + sl_coordinate_lower
            
            for i in range(self.dim):
                if i == self.index:
                    sub_series = str(self.serial*self.part_number + j - (self.part_number - 1))
                    part_sub[sub_series]= copy.deepcopy(self.subregion)
                    part_sub[sub_series][self.index] = [l_coordinate_lower, l_coordinate_upper]
        return part_sub
            
    # def fun_reg_branching(sl_coordinate_lower: np.ndarray, sl_coordinate_upper: np.ndarray, i_dim: int, i_B: int, sub_r, sub_u: list, part_list:list, z: int,list_subr) -> list:
    #     
    #     assert sl_coordinate_lower.ndim == 2, 'sl_coordinate_lower matrix must be 2 dimensional'
    #     assert sl_coordinate_upper.ndim == 2, 'sl_coordinate_upper matrix must be 2 dimensional'
    #     sl_coordinate_upper = sl_coordinate_upper.tolist()
    #     sl_coordinate_lower = sl_coordinate_lower.tolist()
    #     list_star = [[] for i in range(2*len(sub_u))]
    #     for j in range(len(sub_u)):
    #         #m = (np.array(sl_coordinate_upper[j]) - np.array(sl_coordinate_lower[j])).tolist()
    #         #f_value = choice(m)
    #         #i_index = m.index(f_value)
    #         i_index = part_list[z]
    #         for i in range(0, i_B):
    #             l_coordinate_lower = copy.deepcopy(sl_coordinate_lower)
    #             l_coordinate_upper = copy.deepcopy(sl_coordinate_upper)
    #             l_coordinate_lower[j][i_index] = float((sl_coordinate_upper[j][i_index] - sl_coordinate_lower[j][i_index]) * i) / i_B + \
    #                                                     sl_coordinate_lower[j][i_index]
    #             l_coordinate_upper[j][i_index] = float((sl_coordinate_upper[j][i_index] - sl_coordinate_lower[j][i_index]) * (i + 1)) / i_B + \
    #                                                     sl_coordinate_lower[j][i_index]
    #             a = [[0]*2 for i in range(0, i_dim)]
    #             for i in range(0, i_dim):
    #                 a[i][0] = l_coordinate_lower[j][i]
    #                 a[i][1] = l_coordinate_upper[j][i]
    #             sub_r.append(a)
    #             list_star[2*j] = 2*(list_subr[j]) -1
    #             list_star[2*j+1] = 2*(list_subr[j])
                    

    #     return sub_r,list_star