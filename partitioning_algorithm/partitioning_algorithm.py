
import copy
from Functional.__tools__ import select_regions, vol
import numpy as np
from treelib import Node, Tree

class partitioning:
    def __init__(self, subregions:dict,  dim:int, uni_sample: dict, 
                 uni_rob: dict, iteration: int, group_result:dict, grouping: str,
                 group_sample_num: dict, iter_group:int, region_vol: float, tree,
                 re_num: int):
        '''
       Partitioning Algorithm
       Parameters:
    #         subregion: region need to be partitioned in dict format for one iteration
    #         dim_index (int): indicate the dimesion needed to be partitioned
    #         dim(int): dimension
            uni_sample: previous uniform sampling accumulated points
            uni_rob: corresponding rob values
            iteration: current algorithm iteration
            group_result: grouping results with subregions serial numbers
            grouping: whether use grouping method
            group_samle_number: sample numbers for next iteration of subregions by grouping method
            iter_group: iteration to start grouping
            region_vol: whole region volumn
            part_number (int): how many subnode that needed to be generated by one root    
   
    #     Returns:
    #         part_sub (dist): subregions with new serial numbers
        '''
        self.subregions = subregions ##subregions that needed to be partitioned
        # self.dim_index = dim_index
        self.dim = dim
        self.uni_sample = uni_sample
        self.uni_rob = uni_rob
        self.iteration = iteration
        self.group_result = group_result
        self.grouping = grouping
        self.group_sample_num = group_sample_num
        self.iter_group = iter_group
        self.region_vol = region_vol
        self.tree = tree
        self.re_num = re_num
        
        

    def __condition__(self, sub_index):

        assert len(self.subregions[sub_index][0]) == self.dim
        assert len(self.subregions[sub_index][1]) == self.dim
        


    def partitioning_algorithm(self):

        uni_select_X = {}
        uni_select_Y = {}
        part_sub = {}
        upd_sample_g = {}
        
        for sub_index in self.subregions.keys():
            self.__condition__(sub_index)
            
            tar_node = self.tree.get_node(str(sub_index))
            dim_index = (tar_node.data['dim_index']+1) % self.dim
            #print('pre', tar_node.data['dim_index'])
            #rint('upd', dim_index)
            
            sl_coordinate_upper = self.subregions[sub_index][dim_index][1]
            sl_coordinate_lower = self.subregions[sub_index][dim_index][0]
           
            if self.iteration > self.iter_group and self.grouping != '0' :
                #if vol(self.subregions[sub_index], self.dim) < 0.125* self.region_vol:
                if sub_index in self.group_result['group1'] or sub_index in self.group_result['group6']:#\
                    #or sub_index in self.group_result['group5']:
                    self.re_num +=1
                    self.tree.create_node("n"+str(self.re_num), str(self.re_num), parent = str(sub_index), data = 
                                          {'region': self.subregions[sub_index], 
                                           'dim_index': tar_node.data['dim_index']})
                    part_sub[str(self.re_num)] = self.subregions[sub_index]
                    uni_select_X[str(self.re_num)] = self.uni_sample[sub_index]
                    uni_select_Y[str(self.re_num)] = self.uni_rob[sub_index]
                    upd_sample_g[str(self.re_num)] = self.group_sample_num[sub_index]
                    continue
                
            if self.iteration != 0:
                if sub_index in self.group_result['group2'] or sub_index in self.group_result['group5']:
                    part_number = 2
                if sub_index in self.group_result['group3'] or sub_index in self.group_result['group4']:
                    part_number = 3
            else:
                part_number = 2
            for j in range(part_number): 
                
                
                l_coordinate_lower = float((sl_coordinate_upper - sl_coordinate_lower))* j / part_number+ \
                                                        sl_coordinate_lower
                l_coordinate_upper = float((sl_coordinate_upper- sl_coordinate_lower) * (j + 1)) / \
                                                        part_number + sl_coordinate_lower
                
                self.re_num += 1
                part_sub[str(self.re_num)]= copy.deepcopy(self.subregions[sub_index])
                part_sub[str(self.re_num)][dim_index] = [l_coordinate_lower, l_coordinate_upper]
                self.tree.create_node("n"+str(self.re_num), str(self.re_num), parent = str(sub_index), 
                                      data ={'region': part_sub[str(self.re_num)], 
                                           'dim_index': dim_index})
                
                if self.iteration != 0:
                    #print('series:',sub_series)
                    uni_select_X[str(self.re_num)], uni_select_Y[str(self.re_num)] = select_regions(self.uni_sample[sub_index],
                                                        part_sub[str(self.re_num)], self.uni_rob[sub_index], 
                                                        self.dim)
                    if self.grouping == '1' and self.iteration > self.iter_group:
                        upd_sample_g[str(self.re_num)] = self.group_sample_num[sub_index]
                    
                    # if self.grouping == '1' and self.iteration > self.iter_group:
                    #     #if vol(self.subregions[sub_index], self.dim) <= 0.125* self.region_vol:
                    #     upd_sample_g[str(sub_series)] = self.group_sample_num[sub_index]
                    
      
        print(self.tree.show(stdout=False))
            
        return part_sub, uni_select_X, uni_select_Y, self.re_num, upd_sample_g
            
